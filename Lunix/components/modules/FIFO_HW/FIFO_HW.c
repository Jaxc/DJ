/*  FIFO_HW.c - The simplest kernel module.
 */
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/io.h>
#include <linux/interrupt.h>

#include <linux/proc_fs.h>  /* Needed for Proc File System Functions */
#include <linux/seq_file.h> /* Needed for Sequence File Operations */

#include <linux/of_address.h>
#include <linux/of_device.h>
#include <linux/of_platform.h>

/* Standard module information, edit as appropriate */
MODULE_LICENSE("GPL");
MODULE_AUTHOR
    ("Xilinx Inc.");
MODULE_DESCRIPTION
    ("FIFO_HW - loadable module template generated by petalinux-create -t modules");

#define DRIVER_NAME "FIFO_HW"

/* Simple example of how to receive command line parameters to your module.
   Delete if you don't need them */
unsigned myint = 0xdeadbeef;
char *mystr = "default";
struct resource *res;  
unsigned long remap_size;
unsigned long *base_addr;

module_param(myint, int, S_IRUGO);
module_param(mystr, charp, S_IRUGO);

unsigned char current_word;
unsigned char read_adress;
unsigned char write_adress;

struct FIFO_HW_local {
	int irq;
	unsigned long mem_start;
	unsigned long mem_end;
	void __iomem *base_addr;
};

static irqreturn_t FIFO_HW_irq(int irq, void *lp)
{
	printk("FIFO_HW interrupt\n");
	return IRQ_HANDLED;
}


 static int proc_FIFO_HW_show(struct seq_file *p, void *v)
 {
     u32 FIFO_value;
     FIFO_value = ioread32(base_addr);
     seq_printf(p, "0x%x", FIFO_value);
     return 0;
 }

static int proc_FIFO_open(struct inode* inode, struct file* file){
    unsigned int size = 16;
      char *buf;
      struct seq_file *m;
      int res;
  
      buf = (char *)kmalloc(size * sizeof(char), GFP_KERNEL);
      if (!buf)
          return -ENOMEM;
  
      res = single_open(file, proc_FIFO_HW_show, NULL);
  
      if (!res) {
          m = file->private_data;
          m->buf = buf;
          m->size = size;
      } else {
          kfree(buf);
      }
      
      current_word = 0;

      return res;
}

static int proc_FIFO_read(struct inode* inode, char __user *buffer, struct file* filp){
    u32 FIFO_value;
    if (current_word) { return 0;}
    if (write_adress == read_adress) {
      printk(KERN_WARNING,"FIFO empty\n");
      return 0;
    }
    
    FIFO_value = ioread32(base_addr + (read_adress * 4));




    
    buffer[0] = (FIFO_value >> 24) & 0xFF;
    buffer[1] = (FIFO_value >> 16) & 0xFF;
    buffer[2] = (FIFO_value >> 8) & 0xFF;
    buffer[3] = FIFO_value & 0xFF;
    buffer[4] = '\n';
    //printk("<1>%c%c%c%c",buffer[0],buffer[1],buffer[2],buffer[3]);
    //printk("<1> 0x%08x\n",FIFO_value);
    read_adress++;
    current_word++;


    return 5;
}

static int proc_FIFO_write(struct file *file, const char __user * buf,
                  size_t count, loff_t * ppos){

      if ((unsigned char)(write_adress + 1) == read_adress){
        printk(KERN_WARNING,"FIFO full!");
        return count;
      }

      char FIFO_phrase[4];
      u32 FIFO_v ;
 
 /*     if (count < 11) {
          if (copy_from_user(FIFO_phrase, buf, count))
              return -EFAULT;
 
         FIFO_phrase[count] = '\0';
     }
 */
     //printk("<1>%c%c%c%c\n",buf[0],buf[1],buf[2],buf[3]);
     //printk("<1>0x%08x,0x%08x,0x%08x,0x%08x\n",buf[0],buf[1],buf[2],buf[3]);
     //FIFO_v = (buf[0]<<24) + (buf[1]<<16) + (buf[2]<<8) + buf[3];

     //FIFO_value = (int ) buf;
     //simple_strtoul(FIFO_phrase, NULL, 0);
     //FIFO_v = 0x4A617863;
     //printk("<1> 0x%08x\n",FIFO_v);
    if (buf[0] == '\n') {
      FIFO_v = 0;
      return count;
    }
    else if (buf[1] == '\n'){
      FIFO_v = (buf[0]<<24);
    }
    else if (buf[2] == '\n'){
      FIFO_v = (buf[0]<<24) + (buf[1]<<16);
    }

    else if (buf[3] == '\n'){
      FIFO_v = (buf[0]<<24) + (buf[1]<<16) + (buf[2]<<8);
    }

    else{
      FIFO_v = (buf[0]<<24) + (buf[1]<<16) + (buf[2]<<8) + buf[3];
    }
     wmb();
     iowrite32(FIFO_v, base_addr+write_adress*4);
     write_adress++;
     //printk("<1> write adress 0x%08x, read adress 0x%08x\n",write_adress,read_adress);

    return (count < 4) ? count : 4;
}

  static const struct file_operations proc_FIFO_operations = {
      .open = proc_FIFO_open,
      .read = proc_FIFO_read,
      .write = proc_FIFO_write,
      .release = single_release
  };

static int FIFO_HW_probe(struct platform_device *pdev)
{
    struct proc_dir_entry *FIFO_proc_entry;
     int ret = 0;
 
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     printk("<1>Start adress 0x%08x, end adress 0x%08x", res->start, res->end);
     if (!res) {
         dev_err(&pdev->dev, "No memory resource\n");
         return -ENODEV;
     }
 
     remap_size = res->end - res->start + 1;
     if (!request_mem_region(res->start, remap_size, pdev->name)) {
         dev_err(&pdev->dev, "Cannot request IO\n");
         return -ENXIO;
     }
 
     base_addr = ioremap(res->start, remap_size);
     if (base_addr == NULL) {
         dev_err(&pdev->dev, "Couldn't ioremap memory at 0x%08lx\n",
             (unsigned long)res->start);
         ret = -ENOMEM;
         goto err_release_region;
     }

     FIFO_proc_entry = proc_create(DRIVER_NAME, 0, NULL,
                        &proc_FIFO_operations);
     if (FIFO_proc_entry == NULL) {
         dev_err(&pdev->dev, "Couldn't create proc entry\n");
         ret = -ENOMEM;
         goto err_create_proc_entry;
     }
 
     printk(KERN_INFO DRIVER_NAME " probed at VA 0x%08lx\n",
            (unsigned long) base_addr);
 
     return 0;
 
  err_create_proc_entry:
     iounmap(base_addr);
  err_release_region:
     release_mem_region(res->start, remap_size);
 
     return ret;
}

 static void FIFO_HW_shutdown(struct platform_device *pdev)
 {
    iowrite32(0, base_addr);
 }

static int FIFO_HW_remove(struct platform_device *pdev)
{
	//struct device *dev = &pdev->dev;
	//struct FIFO_HW_local *lp = dev_get_drvdata(dev);
	//free_irq(lp->irq, lp);
  FIFO_HW_shutdown(pdev);
  remove_proc_entry(DRIVER_NAME, NULL);
  iounmap(base_addr);
	release_mem_region(res->start, remap_size);
	//kfree(lp);
	//dev_set_drvdata(dev, NULL);
	return 0;
}

#ifdef CONFIG_OF
static struct of_device_id FIFO_HW_of_match[] = {
	{ .compatible = "xlnx,FIFO-top-1.0", },
	{ /* end of list */ },
};
MODULE_DEVICE_TABLE(of, FIFO_HW_of_match);
#else
# define FIFO_HW_of_match
#endif


static struct platform_driver FIFO_HW_driver = {
	.driver = {
		.name = DRIVER_NAME,
		.owner = THIS_MODULE,
		.of_match_table	= FIFO_HW_of_match,
	},
	.probe		= FIFO_HW_probe,
	.remove		= FIFO_HW_remove,
  .shutdown = FIFO_HW_shutdown,
};

static int __init FIFO_HW_init(void)
{
	printk("<1>Hello module world.\n");
	printk("<1>Module parameters were (0x%08x) and \"%s\"\n", myint,
	       mystr);
    read_adress = 0;
    write_adress = 0;
	return platform_driver_register(&FIFO_HW_driver);
}


static void __exit FIFO_HW_exit(void)
{
	platform_driver_unregister(&FIFO_HW_driver);
	printk(KERN_ALERT "Goodbye module world.\n");
}

module_init(FIFO_HW_init);
module_exit(FIFO_HW_exit);

